# mysql并发处理

## 问题： 婚礼项目中，两人共用同一用户数据

### 从体验上无论怎么考虑，都会出现，A设置了a，B也去设置了a为b，A再看到这个设置会疑惑自己改了还是没改。

1. 脏读，指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。

2. 不可重复读，指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。

3. 幻读，指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

4. 第一类丢失更新，A事务撤销时，把已经提交的B事务的更新数据覆盖了。
  1. 存款总1000元，A事务取款100元，B事务存入100元
  2. A先开始，读到1000存款
  3. B开始，读到1000存款
  4. B转账，将数据修改为1100，并存
  5. A取款，修改存款为900
  6. A发现数据被修改过，没存，直接回滚到1000元（此时就少了100元）

5. 第二类丢失更新，A事务覆盖B事务已经提交的数据，造成B事务所做的操作丢失 
  1. 存款总1000元，A事务取款100元，B事务存入100元 
  2. A先开始，读到1000存款
  3. B开始，读到1000存款
  4. B转账，将数据修改为1100，并存
  5. A取款，修改为900
  6. A直接存，造成B的操作数据丢失

## 结论，开发时实现数据不出错误即可

## 处理思路

1. 悲观锁 （多写场景）
  1. 防止多人同时修改某条数据的最好办法就是，直接对该条数据进行加锁以防止并发。
  1. 操作之前上锁
1. 乐观锁（多读场景）
  1. 假设数据一般情况下不会造成冲突，在数据进行提交更新的时候，才会对数据的冲突与否进行检测。
  1. 直到提交之前才上锁

## 具体实现

1. 悲观锁 （多写场景）
  1. 在对记录进行修改前，先尝试为该记录加上排他锁(exclusive locks)。
  2. 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。
  3. 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
  4. 期间如果有其他对该记录做修改或加排他锁的操作，都会等待解锁或直接抛出异常。
  5. mysql
    1. set autocommit=0
    2. begin
    3. select valueKey from table1 where id=1 for update
    4. update table1 set valueKey=1 where id=1
    5. commit
    6. *innoDB 默认行级锁，要使用索引，若找不到索引，会锁整张表*
2. 乐观锁（多读场景）
  1. 冲突检测。
  2. 数据更新。
  3. mysql
    1. select valueKey from table1 where id=1 // valueKey为3
    2. update table1 set valueKey=2 where id=1 and valueKey=3
    3. *以上会出现ABA问题*
      1. 当某一线程，将valueKey改为2，又改为3
      2. 虽然当前线程sql最后还是执行成功了，但和逻辑不符。
    4. 某些情况下粒度太细，高并发体验差。
  4. mysql 2.0
    1. 增加一个 version。
      1. 每修改数据一次，version 就自增一次。
    2. 缩小乐观锁粒度 （version粒度比较大）
      1. 例如，某库存商品被秒杀。
      1. update valueKey set valueKey=valueKey-1 where id=1 and valueKey-1>0

## 如何选择

1. 响应效率：
  1. 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。
  2. 乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。
2. 冲突频率：
  1. 如果冲突频率非常高，建议采用悲观锁，保证成功率。
  2. 冲突频率大，选择乐观锁会需要多次重试才能成功，代价比较大。
3. 重试代价: 
  1. 如果重试代价大，建议采用悲观锁。
  2. 悲观锁依赖数据库锁，效率低。
  3. 更新失败的概率比较低。
4. 乐观锁如果有人在你之前更新了，你的更新应当是被拒绝的，可以让用户重新操作。
5. 悲观锁则会等待前一个更新完成。