# 服务器

1. docker，是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。
  1. 软件更新发布及部署低效，过程繁琐且需要人工介入.
    1. Docker的使用简单至极，从开发的角度来看就是三步走：构建(打包镜像文件)，运输（打包好了直接复制），运行。
  2. 环境一致性难以保证，不同环境之间迁移成本太高
    1. 构建镜像的时候就处理完了服务程序对于系统的所有依赖。
  3. 开发和测试人员难以保持环境同步，运维同学没有标准
    1. Docker于开发者而言提供了一种开发环境的管理办法，与测试人员而言保证了环境的同步，于运维人员提供了可移植的标准化部署流程。

2. nginx, 高性能的HTTP和反向代理web服务器.
  1. 多数系统上直接运行
  2. 使用c编写，开销低，效率高
  3. 无缓存的反向代理加速，简单的负载均衡和容错。

3. RabbitMQ, 高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）.
  1. 特点
    1. 提供可靠性消息投递模式、返回模式
    2. 集群模式丰富，表达式配置，HA模式，镜像队列模型
    3. 保证数据不丢失的前提做到高可靠性、可用性
  1. 应用场景
    1. 异步处理。把消息放入消息中间件中，等到需要的时候再去处理。
    2. 流量削峰。例如秒杀活动，在短时间内访问量急剧增加，使用消息队列，当消息队列满了就拒绝响应，跳转到错误页面，这样就可以使得系统不会因为超负载而崩溃。
    3. 日志处理
    4. 应用解耦。假设某个服务A需要给许多个服务（B、C、D）发送消息，当某个服务（例如B）不需要发送消息了，服务A需要改代码再次部署；当新加入一个服务（服务E）需要服务A的消息的时候，也需要改代码重新部署；另外服务A也要考虑其他服务挂掉，没有收到消息怎么办？要不要重新发送呢？是不是很麻烦，使用MQ发布订阅模式，服务A只生产消息发送到MQ，B、C、D从MQ中读取消息，需要A的消息就订阅，不需要了就取消订阅，服务A不再操心其他的事情，使用这种方式可以降低服务或者系统之间的耦合。
  1. AMQP
    1. Server：接收客户端的连接，实现AMQP实体服务。
    2. Connection：连接，应用程序与Server的网络连接，TCP连接。
    3. Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。
    4. Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。5. 5.5. Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。
    6. Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。
    7. Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。
    8. Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。
    9. RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”。
    10. Queue：消息队列，用来保存消息，供消费者消费。
  1. 常用交换器
    1. Direct Exchange 完全匹配
    2. Topic Exchange 模糊匹配
    3. Fanout Exchange 不匹配
    4. Headers Exchange 使用headers属性进行匹配


4. express， Node.js Web 应用程序开发极简框架
  1. 实现客户端与服务器的通讯，服务器与数据库之间的交互, 但是回调嵌套严重
  1. 中间件的执行顺序为顺序执行
  1. Application
    1. web服务器模块
    1. 抽象了web服务器的主要贡呢和接口，如监听、事件、加载中间件、get\post请求等
  1. Request 请求
  1. Response 响应
  1. Router 路由

5. koa 相比express更小，更健壮
  1. 使用 Generator(yield暂停)/(Async/Await)，可以免除重复繁琐的回调函数嵌套
  1. 中间件的执行顺序为洋葱圈
  2. Application、Request、Response、
    1. Context 上下文 抽象了整个请求逻辑，从客户端发起的请求，到服务器计算，再到返回的数据，现在都是一回事了。

6. egg koa2之上的企业级框架
  1. 专注于提供 Web 开发的核心功能和一套灵活可扩展的插件机制。
  1. 一个插件只做一件事，根据自己的业务场景定制配置，开发成本就变得很低。
  1. 约定优于配置 但相比express提供了标准。
  1. 特性
    1. 提供基于 Egg 定制上层框架的能力
    2. 高度可扩展的插件机制
    3. 内置多进程管理 （基于 Cluster的 master，agent，Worker机制IPC通讯）
    4. 基于 Koa 开发，性能优异
    5. 框架稳定，测试覆盖率高
    6. 渐进式开发 => 原始代码 => 插件 => 独立插件 => 沉淀到框架

# 数据库

1. MongoDB 基于分布式文件存储的非关系数据库
  1. 高性能、易部署、易使用，存储数据非常方便
  1. 面向集合存储，易存储对象类型的数据
  1. 文档自由（内嵌文档）
  1. 动态查询， 索引，复制和故障恢复
  1. 使用高效的二进制数据存储
  1. 自用体验
    1. 文档非常自由，随便冗余设计
    2. 事务差
    3. 复杂查询难受
  
2. mysql 
  1. 除以上相同点外
  1. 事务好，查询好，也可以横向扩展。
  1. 自用体验 
    1. 语法有意思。
    1. 查询方便。
    1. 事务太爽了。

1. 关系型数据库和非关系型数据库区别？
  1. 数据bai存储方式不同。
    1. 关系型数据天然就是表格式的。
    2. 非关系型数据不适合存储在数据表的行和列中，而是大块组合在一起。like JSON。
  2. 扩展方式不同。
    1. sql纵向扩展，也就是说提高处理能力，使用速度更快速的计算机。（当然现在sql也可以横向扩展了）
    2. NoSQL数据库是横向扩展的，天然就是分布式的，增加服务器(节点)来分担负载。
  3. 对事务性的支持不同。
    1. SQL数据库支持对事务原子性细粒度控制，并且易于回滚事务。
    2. NoSQL数据库也可以使用事务操作，但稳定性方面没法和关系型数据库比较，所以它们真正闪亮的价值是在操作的扩展性和大数据量处理方面。

3. redis，key-value缓存存储数据库, 速度超快，可持久化不易丢失。

# 网络

1. tcp/ip
  1. TCP
    1. 位于OSI的第四层（传输层）
  1. IP
    1. 位于OSI的第三层（网络层）

1. http, ssl + http = https
  1. HTTP
    1. 超文本传输协议。
    1. 是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。
    1. HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。
    1. HTTP属于OSI的第七层（应用层）
  1. HTTPS
    1. 以安全为目标的HTTP通道
    2. HTTP下加入SSL层
    3. 内容加密，携带证书，对网站服务器进行真实身份认证。
    4. 默认443端口

1. 比喻总结 - IP是一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP。

1. WebSocket 协议
  1. 为什么需要 WebSocket？因为 HTTP 协议有一个缺陷：通信只能由客户端发起。HTTP 协议做不到服务器主动向客户端推送信息。
  1. 最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话。
    1. 建立在 TCP 协议之上，服务器端的实现比较容易。
    2. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443。
    3. 数据格式比较轻量，性能开销小，通信高效。
    4. 可以发送文本，也可以发送二进制数据。
    5. 没有同源限制，客户端可以与任意服务器通信。
    6. 协议标识符是ws（如果加密，则为wss）。
  1. 服务端的实现
    1. Socket.IO


# 前端

1. html5, css3, js Es8
1. vue => uniapp, vant
1. react => AntV

# 开发原理

1. 微服务
  1. 特性
    1. 有自己的堆栈，包括数据库和数据模型；
    2. 通过REST API，事件流和消息代理的组合相互通信；
    3. 和它们是按业务能力组织的，分隔服务的线通常称为有界上下文；
  1. 价值
    1. 可以更轻松地更新代码。
    1. 团队可以为不同的组件使用不同的堆栈。
    1. 组件可以彼此独立地进行缩放，从而减少了因必须缩放整个应用程序而产生的


1. 前后端开发的技术原理
  1. 在浏览器输入网址后发生了什么？
    1. 查找域名对应的IP地址
    2. 浏览器向IP对应的Web服务器发送HTTP请求
    3. 服务器响应，发回网页内容
    4. 浏览器解析网页内容
  1. 前端与后端
    1. 只是从代码被执行的位置来区分。
    1. 前端： 浏览器显示的网页，提供用户与网站进行交互的可视化接口
    1. 后端： 指在服务器中执行的逻辑运算和数据处理，它为前端提供着访问服务
  2. Web服务器
    1. 使用HTTP协议
    2. TCP链接
      1. 建立连接：三次握手
      2. 数据传输
      3. 关闭连接：四次挥手
    3. Socket
      1. 将TCP/IP协议封装成API接口
        1. 创建socket()
        2. 绑定bind()。bind()在这个socket上绑定一个指定的端口号和IP地址。
        3. 监听listen()。随时准备接收客户端发来的连接，客户端亦是。
        4. 接受accept()
        5. 读/写write()/read()
        6. 关闭close()
  3. Web框架
    1. MVC
      1. model(模型)
      2. view(视图)
      3. controller(控制器)
      4. 客户端发送请求，控制器（Controller）首先会拿到请求，然后用模型（Models）从数据库取出所有需要的数据进行必要的处理，将处理后的结果发送给视图（View）视图利用获取到的数据进行渲染生成 Html返回给客户端。



